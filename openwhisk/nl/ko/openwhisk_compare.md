---

copyright:
  years: 2016, 2017
lastupdated: 2017-04-26

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# FaaS(Function as a Service) 비교
{: #openwhisk_faas_compared}

서버리스(serverless) 아키텍처가 모든 컴퓨팅 문제의 해결책은 아니지만 몇 가지 문제는 해결할 수 있습니다. 서버리스(serverless) 디자인을 선택하면 유용할 수 있는 [여러 유스 케이스](./openwhisk_use_cases.html)가 있습니다. 여기에서 다음 아키텍처를 비교합니다.

1. **FaaS(Function as a Service)** - 관리 OpenWhisk입니다. 현재로서는 IBM이 관리된 [OpenWhisk on Bluemix](https://console.ng.bluemix.net/openwhisk)를 제공하는 유일한 공급업체입니다.

2. **IaaS(Infrastructure as a Service)** - OpenWhisk RYO(Roll Your Own)를 포함합니다. 일반 사용자는 Apache Incubation Project에서 OpenWhisk를 다운로드하여 [Bluemix IaaS](https://console.ng.bluemix.net/catalog/?category=devices) 또는 다른 [IaaS 클라우드](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29)에 설치하여 실행할 수 있습니다.

3. **PaaS(Platform as a Service)** - 관리 애플리케이션 런타임입니다. IBM Bluemix CloudFoundry 구현을 통해 관리되는 [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java) 런타임이 좋은 예입니다. 

4. **CaaS(Container as a Service)** - 관리 컨테이너 환경입니다. IBM의 [Containers on Bluemix](https://console.ng.bluemix.net/catalog/?category=containerImages)가 좋은 예입니다.

5. **IaaS(Infrastructure as a Service)** - Java EE 런타임을 포함합니다. IBM의 [WebSphere Application Server VM on Bluemix](https://console.ng.bluemix.net/catalog/services/websphere-application-server)가 좋은 예입니다.

여러 다른 런타임에서 애플리케이션을 개발하고 운영하는 **일반 사용자의 관점**에서 각 아키텍처를 선택하는 장점과 단점을 요약하면 다음과 같습니다.


| 주제 | (1) OpenWhisk FaaS | (2) OpenWhisk RYO | (3) PaaS | (4) CaaS | (5) IaaS+Java EE |
| --- | --- | --- | --- | --- | --- |
|	애플리케이션 단위	|	단일 함수(일반적으로 JavaScript, Swift 또는 Docker 컨테이너의 작은 코드 블록) - 1KB 미만이지만 더 클 수 있습니다. 일반적으로 몇 KB를 초과하지 않습니다.	|	열(1)과 동일	|	사용된 런타임에 따라 다름 - EAR 또는 WAR 파일이거나 기타 언어 고유 애플리케이션 번들일 수 있음 - 일반적으로 크기는 비교적 큼 - 여러 서비스가 번들로 포함된 KB 또는 MB이지만 작게는 단일 서비스일 수 있음	|	Docker 컨테이너는 배치 단위입니다.	|	EAR 또는 WAR 파일과 기타 종속 항목이 포함된 앱 서버가 있는 VM - 일반적으로 GB로 크기가 지정됩니다.	|
|	리소스 풋프린트	|	각 사용자가 메모리, CPU 또는 기타 리소스에 대해 지불하지 않거나 상관하지 않습니다. 조치에는 일부 풋프린트가 있는 동안에는 사용자가 걱정하지 않아도 됨	|	높음. 일반 사용자가 먼저 IaaS 환경을 프로비저닝해야 그 위에 OpenWhisk를 설치하고 구성할 수 있음	|	소형. 일반 사용자가 실행 중인 앱의 메모리와 CPU에 대해서만 지불하고 실행 중이지 않은 앱에 대해서는 지불하지 않음	|	소형에서 중간.	|	높음. 앱이 실행 중인 동안 일반 사용자가 디스크 스토리지, 메모리, CPU 및 기타 컴포넌트에 대해 지불해야 합니다. 중지되면 스토리지 비용만 발생합니다. 	|
|	설치 및 설정	|	필요하지 않음	|	어려움 - 일반 사용자가 모두 수행	|	필요하지 않음	|	중간 - CaaSs 공급업체가 제공한 하드웨어, 네트워킹, OS, 컨테이너 관리 도구 및 일반 사용자가 제공한 이미지, 연결성 및 인스턴스	|	어려움 - 공급업체가 제공한 하드웨어, 네트워킹, OS, 초기 Java EE 설치 및 일반 사용자가 수행하는 추가 구성, 클러스터링, 스케일링	|
|	프로비저닝 시간	|	밀리초	|	열 (4) 및 (5) 참조	|	분	|	분	|	시간	|
|	진행 중 관리	|	없음	|	어려움	|	없음	|	중간	|	어려움	|
|	탄력적 스케일링	|	각 조치는 항상 로드에 따라 기본적으로 즉시 스케일링됩니다. VM 또는 다른 리소스를 미리 프로비저닝하지 않아도 됩니다.	|	제공되지 않음 - 일반 사용자가 IaaS의 컴퓨팅 용량을 제공하고 VM의 스케일링을 관리해야 합니다. VM이 스케일링되면 OpenWhisk가 자동으로 조치를 스케일링하지만 리소스가 미리 프로비저닝되어야 합니다.	|	스케일링이 자동으로 수행되지만 느립니다. 최대 사용이 시작되는 몇 분 동안 스케일 조치가 완료될 때까지 기다려야 합니다. Auto-Scaling 시 주의하여 튜닝해야 합니다. 	|	스케일링이 자동으로 수행되지만 느립니다. 최대 사용이 시작되는 몇 분 동안 스케일 조치가 완료될 때까지 기다려야 합니다. Auto-Scaling 시 주의하여 튜닝해야 합니다. 	|	제공되지 않음	|
|	용량 계획	|	필요하지 않습니다. FaaS는 필요한 만큼의 용량을 자동으로 제공합니다.	|	미리 충분한 용량을 프로비저닝하거나 스크립팅해야 합니다.	|	일부 용량 계획이 필요하지만 일부 자동 용량 증가가 제공됩니다.	|	일부 용량 계획이 필요하지만 일부 자동 용량 증가가 제공됩니다.	|	피크 워크로드를 처리하는 데 충분한 용량을 정적으로 프로비저닝해야 합니다.	|
|	지속적 연결 및 상태	|	매우 제한됨 - 컨테이너 캐싱의 경우를 제외하고 지속적 연결을 유지할 수 없습니다. 일반적으로 상태는 외부 리소스에 보관되어야 합니다.	|	열(1)과 동일	|	지원됨 - 오랫동안 열린 소켓 또는 연결을 유지할 수 있으며 호출 간에 상태를 메모리에 저장할 수 있습니다.	|	지원됨 - 오랫동안 열린 소켓 또는 연결을 유지할 수 있으며 호출 간에 상태를 메모리에 저장할 수 있습니다.	|	지원됨 - 오랫동안 열린 소켓 또는 연결을 유지할 수 있으며 호출 간에 상태를 메모리에 저장할 수 있습니다.	|
|	유지보수	|	필요하지 않음 - IBM에서 전체 스택을 관리합니다.	|	중요 - 대상 환경에 따라 사용자가 하드웨어, 네트워킹, OS, 스토리지, DB를 프로비저닝하고 OpenWhisk를 설치 및 유지보수 하는 드으이 작업을 수행해야 합니다. 	|	필요하지 않음 - 공급업체에서 전체 스택을 관리합니다.	|	중요 - 사용자가 사용자 정의 이미지를 작성하고 유지보수하며, 컨테이너 및 컨테이너 간 연결을 배치하고 관리하는 등의 작업을 수행해야 합니다.	|	중요 - 사용자가 VM을 할당하고 Java EE 서버를 개별적으로 관리하며 스케일링해야 합니다.	|
|	고가용성(HA) 및 재해 복구(DR)	|	기본/추가 비용 없음	|	ROY(Roll Your Own) 	|	추가 비용을 통해 사용 가능	|	실패한 컨테이너를 자동으로 재시작할 수 있습니다.	|	추가 비용을 통해 사용 가능하며, 반자동입니다. VM은 자동으로 장애 복구될 수 있습니다.	|
|	보안	|	공급업체 제공	|	ROY(Roll Your Own)	|	RYO와 공급업체 제공 혼합	|	RYO와 공급업체 제공 혼합	|	ROY(Roll Your Own)	|
|	개발자 속도	|	가장 높음	|	가장 높음	|	가장 높음	|	평균	|	느림	|
|	리소스 활용도(여전히 지불해야 하는 유휴 리소스)	|	리소스는 요청이 있을 때만 호출되므로 유휴 상태에 있지 않습니다. 워크로드가 없으면 리소스가 할당되지 않으며 비용이 들지 않습니다.	|	이 옵션은 IaaS 또는 CaaS를 사용하므로 비슷한 고려 사항이 열 (4)와 (5)에 적용됩니다.	|	일부 리소스가 유휴 상태일 수 있습니다. 자동으로 크고 작게 스케일링하면 유휴 리소스를 제거할 수 있지만, 항상 몇 개의 인스턴스가 실행 중이어야 하며 용량의 50% 미만으로 사용될 가능성이 큽니다. 인스턴스가 중지되면 비용이 들지 않습니다.	|	열 (3)과 비슷	|	일부 리소스가 유휴 상태일 수 있습니다. Auto-Scaling은 지원되지 않습니다. 항상 몇 개의 인스턴스가 실행 중이어야 하며 용량의 50% 미만으로 사용될 가능성이 큽니다. 인스턴스가 중지되어도 스토리지 비용이 발생할 수 있습니다.	|
|	성숙도	|	이른 성숙도	|	이른 성숙도	|	이른 성숙도	|	중간 성숙도	|	높은 성숙도	|
|	리소스 한계	|	[몇 가지 제한사항이 있음](./openwhisk_reference.html#openwhisk_syslimits)	|	할당된 리소스에 따라 다름	|	아니오	|	아니오	|	아니오	|
|	거의 사용되지 않는 서비스의 대기 시간	|	드물지만 요청의 응답 시간이 처음에는 몇 초가 될 수 있습니다. 그러나 후속 요청은 ms 범위입니다.	|	종속	|	매우 낮음	|	매우 낮음	|	매우 낮음 - 시스템에 충분한 리소스가 있다고 가정	|
|	애플리케이션의 가장 효율적인 유형	|	이벤트 처리, IoT, 모바일 백엔드, 마이크로 서비스. 단일 애플리케이션용이 아닙니다. [유스 케이스](./openwhisk_use_cases.html)를 참조하십시오.	|	열 (1)과 마찬가지지만, 사용자가 비IBM 클라우드에서 실행하거나 온프레미스로 실행하려는 경우에 사용합니다.	|	워크로드가 24x7 로드되는 웹 애플리케이션, 장기간 연결을 연 상태로 두어야 하는 stateful 서비스. 마이크로 서비스 또는 단일 애플리케이션을 실행하는 데 사용할 수 있습니다.	|	마이크로 서비스 애플리케이션에 적합합니다.	|	온프레미스에서 클라우드로 마이그레이션된 기존 엔터프라이즈 애플리케이션. 단일 애플리케이션에 더 적합	|
|	단위 청구 및 비용 청구	|	[100 밀리초 블록당](https://console.ng.bluemix.net/openwhisk/learn/pricing)	|	구현에 따라 다름 - IaaS 또는 CaaS를 사용 중이면 비슷한 고려사항이 적용됨 - 열 (4)와 (5) 참조	|	일반적으로 시간당(드물게 분당) 리소스 번들에 대해 청구(CPU + 메모리 + 디스크 공간)	|	열 (3)과 비슷	|	열 (3)과 비슷	|
|	총 소유 비용(TCO)	|	가장 효율적으로 사용하는 경우 애플리케이션은 대안보다 작은 자릿수의 비용이 들 가능성이 큽니다. 리소스가 자동 스케일링되므로 초과 프로비저닝되는 문제가 없습니다.	|	클라우드 배치에서는 OpenWhisk FaaS보다 비용이 높을 가능성이 크지만 온프레미스 배치에서는 기존 아키텍처보다 저렴할 수 있습니다.	|	비교적으로 낮음 - 사용자가 리소스를 프로비저닝하거나 관리하지 않아도 되며 애플리케이션만 신경쓰면 되지만, 서버리스(serverless)의 경우에 비해 일정 수준 초과 프로비저닝됩니다.	|	중간 - 컨테이너와 애플리케이션을 프로비저닝하고 관리해야 하지만, 서버리스(serverless)의 경우와 PaaS에 비해 일정 레벨 초과 프로비저닝됩니다.	|	비교적 높지만, 레거시 애플리케이션을 클라우드 네이티브 모델로 마이그레이션하면 엄청나게 비싸질 수 있으므로 해당 앱에 가능한 경제적인 선택이 될 수 있습니다.	|
