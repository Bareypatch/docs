---

copyright:
  years: 2016, 2017
lastupdated: 2017-04-26

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# Comparación de Función como servicio
{: #openwhisk_faas_compared}

La arquitectura sin servidor no resulta una panacea para todos los problemas de cálculo, pero sí que resuelve algunos. Existen [muchos casos de uso](./openwhisk_use_cases.html) en los que un diseño sin servidor puede resultar una buena elección. En esta sección compararemos las siguientes arquitecturas:

1. **Función como servicio (FaaS)** - gestionado OpenWhisk. Actualmente, IBM es el único proveedor que ofrece [OpenWhisk en Bluemix](https://console.ng.bluemix.net/openwhisk) gestionado.

2. **Infraestructura como servicio (IaaS)** con OpenWhisk Roll Your Own (RYO). Los usuarios finales pueden descargar OpenWhisk desde Apache Incubation Project e instalarlo y ejecutarlo en [Bluemix IaaS](https://console.ng.bluemix.net/catalog/?category=devices) o en otra [nube IaaS](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29).

3. **Plataforma como servicio (PaaS)** - tiempo de ejecución de aplicaciones gestionado. Un buen ejemplo es un tiempo de ejecución [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java) gestionado por la implementación IBM Bluemix CloudFoundry.

4. **Contenedor como servicio (CaaS)** - entorno de contenedor gestionado. Un buen ejemplo es [Containers on Bluemix](https://console.ng.bluemix.net/catalog/?category=containerImages) de IBM.

5. **Infraestructura como servicio (IaaS)** con tiempo de ejecución Java EE. Un buen ejemplo es [WebSphere Application Server VM on Bluemix](https://console.ng.bluemix.net/catalog/services/websphere-application-server) de IBM.

A continuación encontrará un resumen de los pros y los contras de cada arquitectura desde la **perspectiva de un usuario** que desarrolla y utiliza aplicaciones en estos tiempos de ejecución:


| Tema | (1) OpenWhisk FaaS | (2) OpenWhisk RYO | (3) PaaS | (4) CaaS | (5) IaaS+Java EE |
| --- | --- | --- | --- | --- | --- |
|	Unidad de aplicación	|	Una sola función (generalmente un pequeño bloque de código en JavaScript, Swift o contenedor Docker) - puede tener menos de 1 Kb, pero puede ser mayor. Generalmente no más de unos cuantos Kb.	|	Igual que columna (1)	|	Depende del tiempo de ejecución utilizado - puede ser un archivo EAR o WAR o un paquete de aplicación específico de otro lenguaje, generalmente de tamaño relativamente grande - Kb o incluso Mb con muchos servicios en un paquete, pero puede ser tan pequeño como un solo servicio	|	Contenedor Docker es la unidad de despliegue.	|	VM con App Server con archivo EAR o WAR y otras dependencias - generalmente en unidades de Gb.	|
|	Tamaño de recurso	|	El usuario final no paga ni se preocupa de la memoria, CPU y otros recursos. Aunque la acción ocupe cierto tamaño, el usuario no se tiene que preocupar de eso	|	Alto. El usuario final debe suministrar un entorno IaaS y después instalar y configurar OpenWhisk sobre el mismo	|	Pequeño. El usuario final paga por la memoria y CPU necesarias para ejecutar las apps, pero no paga por las apps que no se ejecutan	|	Pequeño a mediano	|	Alto. El usuario final tiene que pagar por almacenamiento de disco, memoria, CPU y posiblemente otros componentes cuando la app se ejecuta. Cuando está detenida, solo se incurren en costes de almacenamiento	|
|	Instalación y configuración	|	No necesario	|	Alto - todo lo hace el usuario final	|	No necesario	|	Moderado - herramientas de gestión de hardware, red, SO y contenedor proporcionadas por el proveedor de CaaSs, imágenes, conectividad e instancias por el usuario final	|	Alto - instalación de hardware, red, SO y Java EE inicial proporcionada por el proveedor, configuración adicional, clúster y escalado por el usuario final	|
|	Tiempo de suministro	|	Milisegundos	|	Vea las columnas (4) y (5)	|	Minutos	|	Minutos	|	Horas	|
|	Administración continua	|	Ninguna	|	Alto	|	Ninguna	|	Modelado	|	Alto	|
|	Escalado elástico	|	Cada acción se escala de forma instantánea y de modo inherente en función de la carga. No es necesario suministrar las VM ni otros recursos por adelantado	|	No se proporciona - el usuario final debe proporcionar capacidad de cálculo en IaaS y gestionar el escalado de las VM. Una vez escaladas las VM, OpenWhisk escalará la acción automáticamente, pero los recursos se deben suministrar por adelantado	|	Automático, pero escalado lento. Al principio de un pico de varios minutos es posible que los usuarios tengan que esperar a que finalice la acción de escalado. El escalado automático requiere un ajuste cuidadoso	|	Automático, pero escalado lento. Al principio de un pico de varios minutos es posible que los usuarios tengan que esperar a que finalice la acción de escalado. El escalado automático requiere un ajuste cuidadoso	|	No se proporciona	|
|	Planificación de la capacidad	|	No es necesaria. FaaS proporcionará automáticamente la capacidad necesaria	|	Es necesario suministrar suficiente capacidad de antemano o en un script	|	Se necesita cierta planificación de la capacidad, pero se proporciona cierto aumento automático de la capacidad	|	Se necesita cierta planificación de la capacidad, pero se proporciona cierto aumento automático de la capacidad	|	Se necesita suministrar suficiente capacidad de forma estática para gestionar puntas de carga de trabajo	|
|	Conexiones permanentes y estado	|	Muy limitado - no se puede mantener una conexión permanente, excepto en casos de almacenamiento de contenedor en memoria caché. Generalmente el estado se debe mantener en un recurso externo	|	Igual que columna (1)	|	Soportado - se puede mantener una conexión o socket abierto durante mucho tiempo, se puede guardar el estado en memoria entre llamadas	|	Soportado - se puede mantener una conexión o socket abierto durante mucho tiempo, se puede guardar el estado en memoria entre llamadas	|	Soportado - se puede mantener una conexión o socket abierto durante mucho tiempo, se puede guardar el estado en memoria entre llamadas	|
|	Mantenimiento	|	No es necesario - IBM lo gestiona	|	Significativo - en función del entorno de destino, el usuario debe suministrar hardware, red, SO, almacenamiento, BD, instalación y mantenimiento de OpenWhisk, etc.	|	No es necesario - lo gestionado el proveedor	|	Significativo - el usuario debe crear y mantener imágenes personalizadas, desplegar y gestionar contenedores, conexiones entre contenedores, etc.	|	Significativo - el usuario debe asignar las VM, gestionar y escalar servidores Java EE individualmente	|
|	Alta disponibilidad (HA) y Recuperación tras desastre (DR)	|	Inherente / sin costes adicionales	|	Roll Your Own (RYO) 	|	Disponible con cargo adicional	|	Los contenedores anómalos se pueden reiniciar automáticamente	|	Disponible con cargo adicional, semiautomático. Las VM se pueden migrar tras error automáticamente	|
|	Seguridad	|	La proporciona el proveedor	|	Roll Your Own (RYO)	|	Combinación de RYO y proporcionado por el proveedor	|	Combinación de RYO y proporcionado por el proveedor	|	Roll Your Own (RYO)	|
|	Velocidad de desarrollador	|	Máximo	|	Máximo	|	Máximo	|	Medio	|	Lento	|
|	Utilización de recursos (recursos desocupados por los que aún se tiene que pagar)	|	Los recursos nunca están desocupados, ya que solo se invocan cuando hay una solicitud. Cuando no hay carga de trabajo, no hay asignación de recursos ni coste	|	Como esta opción utiliza IaaS o CaaS, se aplican consideraciones similares a las de las columnas (4) y (5)	|	Algunos recursos pueden estar desocupados. El escalado automático hacia arriba y hacia abajo ayuda a eliminar los recursos desocupados, pero siempre tiene que haber un determinado número de instancias en ejecución y es probable que se utilicen a menos del 50 % de su capacidad. Las instancias detenidas no cuestan nada	|	Parecido a la columna (3)	|	Algunos recursos pueden estar desocupados. No se admite el escalado automático. Siempre tiene que haber un determinado número de instancias en ejecución y es probable que se utilicen a menos del 50 % de su capacidad. Las instancias detenidas pueden incurrir en el coste de almacenamiento	|
|	Madurez	|	Madurez temprana	|	Madurez temprana	|	Madurez temprana	|	Madurez moderada	|	Muy maduro	|
|	Límites de recursos	|	[Existen ciertos límites](./openwhisk_reference.html#openwhisk_syslimits)	|	Depende de los recursos asignados	|	No	|	No	|	No	|
|	Latencia para servicios que se utilizan poco	|	Es posible que las solicitudes poco frecuentes muestren un tiempo de respuesta de varios segundos, que se pasará a un rango de milisegundos para las siguientes solicitudes	|	Depende	|	Muy bajo	|	Muy bajo	|	Muy bajo - suponiendo que el sistema tenga suficientes recursos	|
|	Tipo de aplicación Sweet spot	|	Proceso de sucesos, IoT, proceso de fondo móvil, microservicios. Definitivamente no apto para aplicaciones monolíticas. Consulte los [casos de uso](./openwhisk_use_cases.html)	|	Igual que la columna (1), pero cuando el usuario desea trabajar con una nube que no es de IBM o de forma local.	|	Aplicaciones web con una carga de trabajo de tipo 24x7, servicios que necesitan mantener la conexión abierta durante largos periodos de tiempo. Se puede utilizar para ejecutar microservicios o aplicaciones monolíticas	|	Muy adecuado para aplicaciones de microservicios.	|	Aplicaciones tradicionales de empresa migradas de local a la nube. Más adecuado para aplicaciones monolíticas	|
|	Granularidad de los cargos y facturación	|	[Por bloques de 100 milisegundos](https://console.ng.bluemix.net/openwhisk/learn/pricing)	|	Depende de la implementación - si utiliza IaaS o CaaS, se aplican consideraciones similares a las de las columnas (4) y (5)	|	Normalmente se factura por hora (raramente por minuto) por el paquete de recursos (CPU + memoria + cierto espacio de disco)	|	Parecido a la columna (3)	|	Parecido a la columna (3)	|
|	Coste total de propiedad (TCO)	|	Para aplicaciones de tipo sweet spot es probable que el coste sea menor que el de las alternativas. Puesto que los recursos se escalan automáticamente, nunca hay un problema de exceso de suministro	|	Para despliegues en la nube, es probable que resulte más caro que OpenWhisk FaaS, pero para un despliegue local puede resultar más económico que las arquitecturas tradicionales	|	Relativamente bajo - el usuario no tiene que suministrar ni gestionar recursos y solo se tiene que preocupar de su aplicación, pero existe cierto nivel de exceso de suministro en comparación con la opción sin servidor	|	Moderado - el usuario tiene que suministrar y gestionar los contenedores y la aplicación, pero no hay nivel de exceso de suministro en comparación con la opción sin servidor y en comparación con PaaS	|	Relativamente alto, pero teniendo en cuenta que la migración de aplicaciones antiguas al modelo nativo de nube puede resultar muy caro, esta puede ser una opción más viable y económica para este tipo de apps	|
